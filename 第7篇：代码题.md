### 001：实现一个节流函数?

```js
function throttle(callback, delay = 500) {
  let timeoutId = null;
  return function (...args) {
    if (timeoutId) return;
    timeoutId = setTimeout(() => {
      callback.apply(this, args);
      timeoutId = null;
    }, delay);
  }
}

window.onresize = throttle(() => {
  console.log("触发");
});
```

### 002：实现一个防抖函数

```js
function debounce(callback, delay = 500) {
  let timeoutId = null;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback.apply(this, args);
    }, delay);
  }
}
```

### 003：实现一个批量请求函数，能够限制并发量?

```js
function batchRequest(urls, maxConcurrent) {
  const results = [];
  let currentIndex = 0;

  return new Promise((resolve, reject) => {
    function handleRequest(url) {
      return new Promise((resolve, reject) => {
        // 模拟异步请求
        setTimeout(() => {
          console.log(`Requesting: ${url}`);
          // 假设请求成功，将结果添加到数组中
          results.push(`Response from: ${url}`);
          resolve();
        }, 1000);
      });
    }

    async function makeRequest() {
      while (currentIndex < urls.length) {
        const url = urls[currentIndex];
        currentIndex++;

        try {
          await handleRequest(url);
        } catch (error) {
          console.error(`Error requesting ${url}: ${error}`);
        }
      }
    }

    const requestPromises = [];
    
    for (let i = 0; i < maxConcurrent; i++) {
      requestPromises.push(makeRequest());
    }

    Promise.all(requestPromises)
      .then(() => resolve(results))
      .catch((error) => reject(error));
  });
}

// 示例用法
const urls = [
  'https://example.com/api/1',
  'https://example.com/api/2',
  'https://example.com/api/3',
  'https://example.com/api/4',
  'https://example.com/api/5',
];

batchRequest(urls, 2)
  .then((results) => {
    console.log('All requests completed:');
    console.log(results);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
```

### 004：数组转树结构

```js
function buildTree(arr) {
  const treeMap = {};
  const root = [];

  // 构建映射表
  for (const node of arr) {
    const { id, name, parentId } = node;
    treeMap[id] = { id, name, children: [] };
    if (!parentId) {
      root.push(treeMap[id]);
    }
  }

  // 将节点添加到对应的父节点下
  for (const node of arr) {
    const { id, parentId } = node;
    if (parentId !== 0) {
      treeMap[parentId].children.push(treeMap[id]);
    }
  }

  return root;
}

// 示例用法
const arr = [
  { id: 2, name: '部门B', parentId: 0 },
  { id: 3, name: '部门C', parentId: 1 },
  { id: 1, name: '部门A', parentId: 2 },
  { id: 4, name: '部门D', parentId: 1 },
  { id: 5, name: '部门E', parentId: 2 },
  { id: 6, name: '部门F', parentId: 3 },
  { id: 7, name: '部门G', parentId: 2 },
  { id: 8, name: '部门H', parentId: 4 },
];

const tree = buildTree(arr);
console.log(tree);
```

### 005：去除字符串中出现次数最少的字符，不改变原字符串的顺序。

```js
“ababac” —— “ababa”
“aaabbbcceeff” —— “aaabbb”
```

```js
function removeLeastFrequentChars(str) {
  // 1. 计算字符串频率
  const map = {};
  for (let char of str) {
    map[char] = (map[char] || 0) + 1;
  }

  // 2. 查找最小值
  const leastVal = Math.min(...Object.values(map));
  // 3. 拼接结果
  let result = '';
  for (let char of str) {
    if (map[char] !== leastVal) {
      result += char;
    }
  }
  return result;
}

console.log(removeLeastFrequentChars("ababac")); // ababa
console.log(removeLeastFrequentChars("aaabbbcceeff")); // aaabbb
```

### 006：给几个数组, 可以通过数值找到对应的数组名称

```js
// 比如这个函数输入一个1，那么要求函数返回A
const A = [1,2,3];
const B = [4,5,6];
const C = [7,8,9];

function test(num) {

}
```

思路1：X.includes(num)

思路2：转成map结构，直接map[num]获取

### 007：Sleep函数（线程休眠）

```js
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function example() {
  console.log('Start');
  await sleep(2000);
  console.log('End');
}

example();
```

### 008：手写instanceof实现原理

```js
function myInstanceOf(obj, constructor) {
  // 验证参数有效性
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  let proto = Object.getPrototypeOf(obj);

  while (proto !== null) {
    if (proto === constructor.prototype) {
      return true;
    }
    // 如果没有找到，就继续从其原型上找，
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

