### 001：webpack 和 rollup的区别？

1. 打包策略
   - Rollup的主要目标是生成更小、更精简的代码包。它通过静态分析和Tree Shaking等技术，将代码模块按需打包，消除未使用的代码，以减小最终生成的包的体积。
   - Webpack则更注重于处理复杂的应用场景，提供了更丰富的功能和插件生态系统。它可以处理各种类型的资源（如JavaScript、CSS、图片等），支持代码拆分、按需加载、动态导入等特性，以及更复杂的配置选项。
2. 静态和动态分析
   - Rollup在打包过程中使用静态分析，即在编译时就确定模块的依赖关系。这样可以更好地进行Tree Shaking，去除未使用的代码，生成更小的包。
   - Webpack采用动态分析，即在运行时根据模块加载的情况来确定依赖关系。这使得Webpack可以处理动态导入和代码拆分等复杂场景。
3. 生态系统和插件支持
   - Webpack拥有庞大的插件生态系统，提供了丰富的插件和加载器，可以处理各种资源类型，以及提供了许多扩展功能（如热模块替换、代码分割等）。
   - Rollup的插件生态系统相对较小，但也提供了一些常用的插件和功能。
4. 使用场景
   - Rollup适合构建JavaScript库和组件，以及需要生成更小包体积的应用程序。
   - Webpack适合构建复杂的应用程序，处理多种类型的资源，具有更强大的功能和灵活的配置选项。

### 002：webpack 性能优化

webpack性能优化从两个方向来考虑：优化打包速度和优化打包文件大小。

1. 优化打包速度
   - 分环境打包，避免加载多余的插件。
   - 合理配置resolve（alias），减少查找的过程。
   - 缩小构建目标，排除webpack不需要解析的模块。（*配置loader时借助exclude参数*）
   - 利用多线程提升构建速度。（*插件：thread-loader*）
   - 预先编译资源模块。
   - 使用缓存Cache
   - 合理使用sourcemap
2. 优化打包体积
   - 分环境打包，避免加载多余的插件。
   - Tree Shaking
   - 代码压缩
   - 拆分代码（Code Spliting）减少main.js包的体积
   - @babel/preset-env开启按需加载（*useBuiltIns:usage*）
   - 使用Asset Modules时配置maxSize，将部分资源转成base64，减少http请求。

### 003：模块化

1. IIFE-自调用函数
2. CommonJS（同步·nodeJS）
3. AMD（异步·浏览器）
4. CMD（类似AMD，强调按需加载和延迟执行）
5. UMD（兼容CommonJS/AMDCMD）
6. ESM