### 001：HTTP是什么？⭐️

1. HTTP是一种 **超文本传输协议**，是客户端和服务器端请求与应答的标准。
2. HTTP是一种 **应用层协议**，由请求和响应组成，是一个标准的客户端服务器模型。
3. HTTP是一种 **无状态协议**，每个请求与响应之间都是相互独立的，服务器默认情况下无法知道两个请求是否来自同一个客户端。
4. HTTP本质上来说就是一个 **通信规则**，规定了客户端发送给服务器以及服务器发送给客户端的内容格式。

### 002：HTTP和HTTPS的区别？⭐️

1. HTTP 是超文本传输协议，信息是明文传输，HTTPS 协议要比 HTTP 协议**安全**，HTTPS 是具有安全性的 SSL 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性。
2. HTTP默认的端口号为 **80**，HTTPS的默认端口号为 **443**。
3. HTTPS 协议需要 CA 证书。
4. HTTPS 缓存不如 HTTP 高效，会增加数据开销。

### 003：TCP三次握手 ⭐️

1. 第一次握手（**SYN**）：建立连接时，客户端发送SYN包（*syn=x*）到服务器 ，并进入 `SYN_SENT` 状态，等待服务器确认。

2. 第二次握手（**SYN + ACK**）：服务器收到SYN包并确认客户的SYN（*ack=x+1*），同时发送一个自己的SYN包（*syn=y*），即SYN + ACK包，此时服务器进入 `SYN_RCVD` 状态。

3. 第三次握手（**ACK**）：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（*ack=y+1*），此时客户端和服务器进入 `ESTABLISHED`（TCP连接成功）状态，完成三次握手。

### 004：TCP四次挥手

### 005：如何确保数据包传输的可靠性？

TCP协议

- SYN：同步序列编号（确保有序）
- ACK：确认号（解决丢包问题）

### 006：TCP和UDP的区别？⭐️

TCP和UDP是两种常见的传输协议。

1. TCP是连接导向的，提供可靠的数据传输，适用于对数据完整性要求较高的场景。
2. UDP是无连接的，提供实时性较高的数据传输，适用于对时延要求较高、数据丢失可以容忍的场景。
3. TCP有序、可靠，UDP无序、不可靠。
4. TCP没有数据包大小限制，UDP受限于最大传输单元（MTU）的大小（64KB以下）

根据具体需求选择TCP或UDP，TCP适用于可靠性要求高的场景，UDP适用于实时性要求高且数据丢失可以容忍的场景（*音视频流传输/游戏通信/DNS解析/网络广播等*）。

### 007：Cookie 🆚 Session ⭐️

Cookie和Session都是用于跟踪浏览器用户身份的会话方式，他们的区别如下：

1. Cookie工作原理：服务器通过响应头中的 Set-Cookie 头部将 Cookie 信息发送给客户端，客户端将 Cookie 存储在本地。之后，每次请求时，客户端会将存储的 Cookie 通过请求头中的 Cookie 字段发送给服务器。
2. Session工作原理：当用户第一次访问服务器时，服务器会为该用户创建一个唯一的 Session ID，并将该 ID 存储在 Cookie 中发送给客户端。客户端每次请求时，会将 Session ID 通过 Cookie 发送给服务器，服务器根据 Session ID 来识别用户并维护相应的用户数据。

| #          | Cookie                                                     | HttpSession                                                  |
| ---------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 存储位置   | 客户端                                                     | 服务器端                                                     |
| 存储容量   | 单个Cookie保存的数据 <=4KB<br />一个站点最多保存20个Cookie | 没有上限<br />但出于对服务端的性能考虑，不要存放过多的东西<br />并且设置Session删除机制 |
| 安全性     | 对客户端是可见的，以明文保存（不安全）                     | 存储在服务器上，不存在敏感信息泄露的风险                     |
| 服务器压力 | 保存在客户端，不占用服务器资源                             | 保存在服务器端，每个用户产生一个Session，耗费大量内存        |
| 跨域支持   | 支持夸域名访问                                             | 不支持跨域名访问                                             |

### 008：HTTP/浏览器缓存机制 ⭐️⭐️

HTTP 缓存是指客户端和服务器之间在传输资源时，使用缓存来减少重复请求和提高性能的一组规则和策略。

浏览器在第一次请求发生后，再次请求时：

1. 浏览器会先获取该资源缓存的header信息，根据其中的Expires和Cahe-Control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；
2. 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match），由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。

HTTP缓存可以分为两种类型：

1. 强制缓存
   - 强制缓存是由服务器在响应头中设置的指令，用于告知客户端在一定时间内可以直接从缓存中获取资源而无需再次请求服务器。
   - 常用的强制缓存指令包括 Expires 和 Cache-Control 头部字段。
   - Expires 设置一个具体的过期时间，而 Cache-Control 通过 max-age 设置缓存的有效期（秒）。
   - 当客户端发起请求时，如果缓存尚未过期，则直接从缓存中获取资源，而不向服务器发送请求。

2. 协商缓存
   - 协商缓存是通过与服务器进行通信，验证缓存是否仍然有效的一种缓存机制。
   - 客户端在发起请求时，将上次响应中的一些验证信息（如 ETag 或 Last-Modified）发送给服务器。
   - 服务器使用这些验证信息来判断资源是否发生了变化。如果未发生变化，则返回 304 Not Modified 状态码，告知客户端可以从缓存中获取资源。
   - 常用的验证字段包括 If-None-Match 和 If-Modified-Since 头部字段。

### 009：状态码301和302的区别？

- 301：永久重定向
- 302：临时重定向
- 304：协商缓存，告知客户端可以从缓存中获取资源



